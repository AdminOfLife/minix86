<meta charset=utf-8>
<b>x86 decompiler</b>
<br>
<br>
Load a demo: <button id=m8trix>m8trix</button>
<button id=point16b>point16b</button>
<button id=dragonfade>dragonfade</button>
<button id=dirojed>dirojed</button>
<button id=fr01>fr01</button>
<button id=futura>futura</button>
<button id=megapole>megapole</button>
<button id=tube>tube</button>
<button id=tetris>4is256</button>
<button id=atraktor>atraktor</button>
<button id=puls>puls</button>
<button id=symetrie>symetrie</button>
<button id=quatro>quatro</button> or any file:
<input onchange="with(f=new FileReader)readAsArrayBuffer(files[0]),onload=function(){u=new Uint8Array(f.result);if(u.length<=64*1024)d()}"type=file>
<br>
<br>
<pre><table id=t border cellspacing=0 cellpadding=4>
<script>


// SYNTAX
// http://www.imada.sdu.dk/Courses/DM18/Litteratur/IntelnATT.htm

// Intel syntax (ok):
// no prefixes: eax, 1, 80h, ...
// order: instr dest, source
// memory operands: [ebx]
// index/scale/disp/segreg: instr foo,segreg:[base+index*scale+disp] (ex: sub eax,[ebx+ecx*4h-20h])
// implicit sufixes: mov al,bl, mov ax,bx

// AT&T syntax (ko):
// prefixes: %eax, $1, $0x80
// order: instr source, dest
// memory operands: (%ebx)
// index/scale/disp/segreg: instr %segreg:disp(base,index,scale),foo (ex: subl -0x20(%ebx,%ecx,0x4),%eax)
// explicit suffixes: movb %bl,%al, movw %bx,%ax






// DEMOS

// M8TRIX.COM
m8trix.onclick = e => {
  u = [196,28,159,171,71,71,235,249];
  ok = 0;
  d();
}

// POINT16B.COM
point16b.onclick = e => {
  u = [176,18,67,205,16,147,52,2,205,51,147,180,12,226,244,195];
  ok = 0;
  d();
}

// DIROJED
dirojed.onclick = e => {
  u = [176,19,205,16,197,31,56,15,16,39,107,219,229,138,15,2,9,2,143,191,254,2,72,63,75,228,96,254,200,117,231,195];
  ok = 0;
  d();
}
  
// DRAGON FADE
dragonfade.onclick = e => {
  u = [176,18,205,16,81,41,209,254,197,209,249,208,216,95,1,250,209,250,114,8,135,202,247,217,129,193,107,2,180,12,235,226];
  ok = 0;
  d();
}
  
// FRO1
fr01.onclick = e => {
  u = [176,19,245,66,205,16,104,0,160,7,247,227,64,1,248,17,28,247,116,12,216,12,222,4,223,31,45,130,0,135,7,49,193,223,7,216,200,49,235,146,217,201,117,232,222,193,217,250,216,60,223,7,223,70,0,217,243,214,145,12,135,170,235,202];
  ok = 0;
  d();
}

  
// FUTURA
futura.onclick = e => {
  u = [176,19,205,16,142,39,186,234,1,184,28,37,205,33,129,229,255,0,117,12,46,128,54,234,1,8,129,54,58,1,145,74,190,64,1,177,255,137,203,246,211,153,141,69,240,247,246,45,200,0,15,175,195,5,3,63,41,234,144,144,15,175,211,129,194,3,143,1,235,136,240,128,252,30,114,2,0,227,32,222,0,198,246,195,240,117,3,128,236,39,8,230,128,230,64,225,196,254,196,48,216,37,3,63,246,228,212,5,116,6,15,164,200,12,4,16,100,136,5,71,117,166,49,201,187,40,0,101,217,7,153,137,200,247,243,82,153,247,243,80,82,137,230,223,4,223,68,2,223,68,4,217,195,217,251,216,202,217,201,216,203,222,193,217,196,217,251,222,204,222,202,217,201,222,234,217,202,245,114,227,223,28,131,4,80,105,60,64,1,223,28,3,60,223,28,172,100,2,1,192,232,4,52,24,100,136,3,71,131,196,6,226,173,222,6,7,0,101,217,31,73,196,54,0,0,191,141,21,100,243,164,233,36,255,77,186,49,3,176,63,238,74,176,153,238,137,232,212,8,117,4,176,36,238,238,207];
  ok = 0;
  d();
}
  
  
// MEGAPOLE
megapole.onclick = e => {
  u = [142,224,93,176,19,205,16,104,0,160,7,247,197,0,1,116,5,128,54,22,1,8,77,185,255,0,153,190,64,1,137,203,137,248,246,211,247,246,232,151,0,232,148,0,190,108,4,100,2,28,18,52,2,100,1,136,240,16,197,32,222,183,48,178,32,232,134,0,116,33,83,178,16,183,20,100,42,28,100,42,28,48,237,232,116,0,91,116,14,178,24,183,28,100,2,28,232,103,0,116,2,226,179,146,128,254,64,116,42,156,88,158,122,33,132,201,116,4,254,198,117,4,176,255,235,29,32,216,48,240,48,218,32,242,192,224,2,128,226,1,15,69,193,180,255,40,196,136,224,235,4,246,212,32,224,252,212,18,176,16,213,1,133,255,122,1,64,170,15,133,107,255,199,4,17,55,100,199,68,228,1,23,180,9,186,247,1,205,33,233,75,255,146,41,232,15,175,195,5,127,6,195,80,246,195,64,117,27,56,252,115,23,56,212,114,19,246,195,120,117,12,132,237,117,5,168,120,117,4,253,128,196,24,48,236,246,198,16,117,2,0,198,8,244,158,88,195,109,101,103,97,112,111,108,101,36];
  ok = 0;
  d();
}
  
// PULS
puls.onclick = e => {
  u = [176,19,83,186,200,3,205,16,136,216,132,203,122,5,246,232,193,232,7,246,235,136,224,238,178,201,226,236,177,3,75,117,233,104,206,159,7,183,86,219,227,131,0,88,223,0,217,251,220,249,223,0,216,12,217,254,222,12,102,90,6,85,96,137,31,139,5,223,5,247,232,41,23,79,123,245,223,7,102,129,5,205,204,0,0,216,204,217,192,216,206,217,202,216,205,220,234,216,206,222,193,217,202,71,123,235,79,107,16,10,223,25,137,23,2,52,0,251,115,246,153,180,230,17,217,232,21,0,40,204,213,4,4,70,137,69,252,97,69,38,136,2,117,174,228,96,72,117,146,179,0,139,41,211,253,49,213,1,47,0,251,115,244,214,223,16,81,211,233,128,197,37,139,16,247,24,105,232,0,128,43,41,121,2,247,221,209,237,1,234,137,47,0,251,115,236,57,202,64,114,37,179,2,122,223,43,16,64,43,16,128,238,96,107,210,13,139,20,112,2,64,153,43,47,121,2,247,221,1,234,139,47,0,251,115,242,57,202,89,25,210,245,24,209,16,209,128,249,6,115,4,0,212,117,150,195];
  ok = 0;
  d();
}

// 4IS256.COM
tetris.onclick = e => {
  u = [64,205,16,180,5,205,16,104,0,184,7,6,31,191,178,15,137,254,185,28,0,131,239,80,128,195,64,131,238,100,184,186,8,171,131,239,24,171,186,10,0,8,165,193,8,34,68,1,165,74,117,245,36,8,117,224,226,219,57,254,116,4,128,235,32,76,228,64,180,90,247,231,137,213,138,78,136,191,133,7,140,198,8,219,116,20,87,191,178,15,75,79,79,176,48,134,5,12,16,60,57,116,244,64,170,95,186,218,3,236,36,8,116,248,236,36,8,117,251,232,95,0,15,131,130,254,180,2,205,22,32,199,134,199,246,215,96,208,232,115,1,175,208,232,115,2,79,79,193,224,15,115,11,67,183,8,137,230,131,198,16,131,199,80,121,18,193,209,13,209,216,115,249,58,102,136,116,3,193,200,12,134,224,145,232,30,0,115,4,131,196,16,96,97,141,70,0,209,198,115,11,104,82,1,113,11,88,49,192,96,235,200,12,8,104,13,1,83,49,219,209,201,115,11,246,1,8,117,18,136,1,198,65,255,219,67,67,246,195,8,116,234,128,195,72,115,229,91,195,240,99,116,113,54,114,51];
  ok = 0;
  d();
}

// QUATRO.COM
quatro.onclick = e => {
  u = [104,0,160,7,49,237,176,19,182,128,142,218,65,205,16,128,237,2,128,238,4,75,184,16,16,226,242,49,210,185,64,1,137,248,247,241,107,243,3,1,216,131,250,28,116,40,131,250,4,126,35,131,250,25,116,30,129,250,61,1,115,24,131,250,34,124,6,129,250,30,1,126,17,1,240,128,194,8,32,208,208,232,36,8,116,75,176,62,235,71,168,120,117,3,214,235,64,15,172,198,23,48,228,131,232,100,131,234,127,131,230,3,96,219,227,223,70,246,222,118,3,217,254,222,78,3,223,70,252,223,70,248,138,138,203,1,255,209,223,94,252,97,138,138,207,1,255,209,168,16,117,2,52,31,212,16,193,230,4,1,240,136,5,71,15,133,115,255,67,186,218,3,236,36,8,116,251,137,254,165,133,255,117,251,228,96,254,200,15,133,91,255,48,208,1,216,41,248,209,232,195,154,255,211,228,229,240,200,243,200,192,216,194,216,200,217,201,216,200,222,193,217,250,222,126,0,222,193,195,216,193,217,243,222,142,201,1,222,193,195,217,201,195,87,193,231,2,246,37,95,136,224,195,78,79,80];
  ok = 16;
  d();
}

// ATRAKTOR
atraktor.onclick = e => {
  u = [63,128,192,19,205,16,0,198,142,226,0,198,142,234,0,198,142,194,189,255,1,186,200,3,214,238,66,13,195,195,80,238,0,224,208,232,238,0,224,192,232,2,238,88,64,117,236,219,227,217,238,217,238,217,238,77,91,87,232,123,0,6,49,192,101,134,5,100,134,37,192,236,4,36,240,104,0,160,0,224,7,170,226,234,7,137,34,223,2,222,116,9,217,251,220,249,217,192,38,222,13,217,192,216,203,175,217,194,38,222,13,220,193,216,204,222,226,175,38,138,69,3,222,4,222,4,222,124,77,220,201,38,222,13,223,26,105,26,64,1,223,26,112,29,3,26,129,195,160,125,4,128,192,232,3,100,0,7,115,3,100,40,7,52,31,101,0,7,115,3,101,40,7,79,79,117,175,222,217,228,96,72,117,129,105,220,64,2,181,3,96,185,2,0,217,193,222,11,193,11,4,222,3,193,11,4,222,116,1,217,254,226,237,216,204,222,193,221,195,217,192,222,76,6,222,100,23,38,223,31,97,67,67,226,211,15,132,64,255,195,187,119,252,156,254,101,189,88,124,161,120,6,92,139,235,124];
  ok = 0;
  d();
}
  
// SYMETRIE
symetrie.onclick = e => {
  u = [184,19,0,205,16,0,198,142,218,0,198,142,226,104,0,160,7,214,186,200,3,238,66,13,195,15,80,193,232,10,238,246,224,193,232,6,238,88,238,64,117,237,15,49,54,102,137,4,219,227,54,102,255,4,54,219,4,136,2,222,50,217,235,216,201,217,254,217,193,217,254,216,192,217,234,216,203,217,254,100,138,37,138,5,193,232,4,36,15,100,40,37,40,5,213,16,170,226,236,191,160,125,187,65,1,253,100,138,20,172,0,0,208,24,100,0,16,100,208,24,226,240,247,219,252,120,235,193,235,7,217,194,117,227,30,102,64,102,107,192,3,114,24,102,199,2,3,0,0,191,216,10,223,2,217,250,216,201,217,202,245,114,243,222,226,222,194,120,33,15,160,31,115,2,216,194,217,193,216,200,217,193,216,200,222,193,217,236,115,2,216,205,222,241,220,202,222,201,115,2,216,196,198,2,55,217,192,222,10,223,27,105,27,64,1,112,24,198,2,66,217,193,222,10,223,27,3,27,178,255,42,17,192,234,5,0,17,247,219,0,17,31,226,146,228,96,72,15,133,53,255,176,3,205,16,195];
  ok = 0;
  d();
}
  
// TUBE
tube.onclick = e => {
  u = [176,19,205,16,104,0,160,7,140,200,128,196,16,142,224,49,201,186,200,3,137,200,238,66,208,248,120,7,238,246,224,193,232,6,238,176,0,238,121,8,40,200,208,232,238,208,232,238,137,203,100,136,31,226,218,137,203,1,200,211,192,136,198,192,254,5,16,242,100,18,151,255,0,208,234,100,136,23,246,215,100,136,23,226,226,219,227,217,238,128,199,8,191,4,2,216,69,244,87,186,176,255,189,96,255,190,252,1,223,68,214,137,44,223,4,137,20,223,4,177,2,217,195,217,251,217,194,216,201,217,196,216,203,222,233,217,203,222,202,222,203,222,194,217,202,226,230,217,193,220,200,217,193,220,200,222,193,217,250,222,251,217,243,222,76,252,223,28,222,76,252,223,92,1,139,52,141,0,0,224,36,64,176,251,116,15,193,230,2,141,0,40,224,176,240,121,4,209,230,176,208,100,2,0,0,5,71,69,129,253,160,0,117,147,66,131,250,80,117,138,94,191,0,25,181,100,243,165,181,200,78,192,60,2,226,250,228,96,152,72,15,133,101,255,176,3,205,16,41,0,195,60,98,97,122,101];
  ok = 0;
  d();
}

// =============================
// Helpers
// @param n: number
// @param l: length (in bytes)
// @param s: sign
// @param o: temp operand value
// =============================

// Convert a number to base 16
var to16 = (n, l) => {
  return (1e9 + n.toString(16)).slice(-2 * l);
}

// Same, with h suffix
var toh = (n, l) => {
  return to16(n, l) + "h";
}

// Convert a byte into a 8-bit signed offset (using 2-complement) + 2 (to include PC incrementation)
var toSignedOffset8 = (n) => {
  n = n & 0xFF;
  return (n >= 0x80 ? n - 256 : n) + 2;
}

// Read the next byte
// Updates the global vars b (instruction binary code in big endian), and l (instruction length)
var imm8 = (o) => {
  i++;
  b = (b * 256) + u[i];
  o = u[i];
  l ++;
  return o;
}

// Read the next 2 bytes in little endian
// Updates the global vars b (instruction binary code in big endian), and l (instruction length)
var imm16 = (o) => {
  o = imm8();
  i++;
  b = (b * 256) + u[i];
  o = (u[i] * 256) + o;
  l++;
  return o;
}

// Interpret a ModR/M byte in 16-bit mode
// Ref: http://ref.x86asm.net/coder32.html#modrm_byte_16
// @param s1 (optional): first operand size/type: 0: r8(/r), 1: r16(/r), 2: r32(/r), 3: mm(/r), 4: xmm(/r), 5: Sreg, 6:eee, 7: eee
// @param s2 (optional): second operand size/type
// @param oe (optional): operation encoding: 0: MR (default), 1: RM (also: 2: FD, 3: TD, 4: OI, 5: MI)
var modRM = (o, s1, s2, oe) => {
  
  var ret = "", op1, op2;
  
  // Mod (bits 12xxxxxx)
  var mod = (o >> 6) & 0b11;
  
  // Operand 1 (bits xx345xxx)
  var op1 = (o >> 3) & 0b111;
  
  // Operand 2 (bits xxxxx678)
  var op2 = o & 0b111;
  
  // Mod 0b11
  if(mod == 0b11){
  
    // s1
    // --
    
    // r8
    if(s1 == 0){
      ret += ["0", "1", "2", "3", "4", "ch", "dh", "7"][op2];
    }
    
    // r16
    if(s1 == 1){
      ret += ["ax", "cx", "dx", "bx", "sp", "bp", "si", "di"][op1];
    }
    
    // Sreg
    if(s1 == 5){
      ret += ["es", "cs", "ss", "ds", "fs", "gs", "res.", "res."][op1];
    }
    
    // s2
    // --
    
    // r8
    if(s2 === 0){
      // "=== 0" to avoid matching undefined
    }
    
    // r16
    if(s2 == 1){
      ret += "," + ["ax", "cx", "dx", "bx", "sp", "bp", "si", "di"][op2];
    }
  }
  
  // RM (reverse operands 1 and 2)
  if(oe == 1){
    ret = ret.split(",").reverse().join(",");
  }
  
  // Debug
  //ret += "<td>mod = " + mod.toString(2) + ", op1 = " + op1.toString(2) + ", op2 = " + op2.toString(2);
  
  return ret;
}

// =======
// Globals
// =======

// CPU mode (16b or 32b). TODO: figure out why it is 16 by default and how/if it can be modified. And if it can have a better name
var cpu_mode = 16;

// 8-bit registers when they're used as operands
r8 = ["al", "1", "2", "3", "4", "5", "dh", "7"];
r16 = ["0", "cx", "2", "3", "4", "5", "6", "di", "ax", "cx", "a?", "bx", "c?", "d?", "e?", "f?"];


// ===========
// Decompiler
// ===========
d = function(){
  
  // Table header
  h = "<tr><th>@<th>hex<th>asm";
  
  // Loop on all bytes
  for(i = 0; i < u.length; i++){
  
    // Initialization
    // ===============
    
    // Current instruction's address
    a = i;
    
    // Current instruction's bytes
    b = u[i];
    
    // Second nibble of the instruction (bits 0-4)
    n = b & 0b1111;
    
    // Current instruction's length
    l = 1;
    
    // Current instruction's asm code
    c = "";
    
    // Operands
    o = 0;
    p = 0;
    q = 0;
    r = 0;
    
    // Parse
    // =====
    
    // 0x01 add r/m16/32 r16/32
    // Ref: http://ref.x86asm.net/coder32.html#x01
    if(b == 0x01){
      o = imm8();
      c = "add ";
      if(o == 0xD8){
        c += "bx,ax";
      }
    }
    
    // 0x07 pop ES
    // Ref: http://ref.x86asm.net/coder32.html#x07
    if(b == 0x07){
      c = "pop es";
    }
    
    // 0x31 xor r/m16/32 r16/32
    // Ref: http://ref.x86asm.net/coder32.html#x31
    if(b == 0x31){
      c = "xor ";
      o = imm8();
      c += modRM(o,1,1);
    }
    
    // 0x4...
    if(b >> 4 == 0x4){
    
      // 0x40 - 0x47: inc r16/32
      // Ref: http://ref.x86asm.net/coder32.html#x40
      if((b & 0b1111) < 0x8){
        c = "inc " + r16[n];
      }
      
      // 0x48 - 0x4F dec r16/32
      // http://ref.x86asm.net/coder32.html#x48
      else{
        c = "dec " + r16[n];
      }
    }
    
    // 0x68 push Imm16/32
    // Ref: http://ref.x86asm.net/coder32.html#x68
    
    if(b == 0x68){
      o = imm16();
      c = "push " + toh(o,2);
    }
    
    // 0x6B imul r16/32 r/m16/32 imm8
    // Ref: http://ref.x86asm.net/coder32.html#x6B
    if(b == 0x6B){
      o = imm8();
      p = imm8();
      c = "imul " + toh(p,1);
      if(o == 0xF3){
        c += ",bx,si";
      }
    }
    
    // 0x74 jz/je rel18
    // Ref: http://ref.x86asm.net/coder32.html#x74
    if(b == 0x74){
      o = imm8();
      c = "je ???";// + toh();
    }
    
    // 0x7E jle/jng rel18
    // Ref: http://ref.x86asm.net/coder32.html#x7E
    if(b == 0x7E){
      o = imm8();
      c = "jle ???";// + toh();
    }
    
    // 0x80 add r/m8 imm8
    // Ref: http://ref.x86asm.net/coder32.html#x80
    if(b == 0x80){
      o = imm8();
      p = imm8();
      c = "sub " + modRM(o,0) + "," + toh(p,1);
    }
    
    // 0x81 many things
    // Ref: http://ref.x86asm.net/coder32.html#x81
    if(b == 0x81){
      o = imm8();
      p = imm16();
      
      // 7: cmp r/m16/32 imm16/32
      if(o == 0xFA){
        c = "cmp " + toh(p,2) + ",dx";
      }
    }
    
    // 0x83 many things
    // Ref: http://ref.x86asm.net/coder32.html#x83
    if(b == 0x83){
      o = imm8();
      p = imm8();
      
      // 7: cmp r/m16/32 imm8
      if(o == 0xFA){
        c = "cmp " + toh(p,1) + ",dx" 
      }
    }
    
    // 0x89 mov r/m16/32 r16/32 (Op/En = MR)
    // Ref: http://ref.x86asm.net/coder32.html#x89
    // Intel manual: vol.2B 4-35 (p.715)
    if(b == 0x89){
      c = "mov ";
      o = imm8();
      c += modRM(o,1,1,1);
    }
    
    // 0x8E mov r/m16/32 r/m16 (Op/En = RM)
    // Ref: http://ref.x86asm.net/coder32.html#x8E
    if(b == 0x8E){
      c = "mov ";
      o = imm8();
      c += modRM(o,5,1);
    }

    // 0x9F lahf AH
    // Ref: http://ref.x86asm.net/coder32.html#x9F
    if(b == 0x9f){
      c = "lahf";
    }
    
    // 0xAB stos(w) m16 AX
    // Ref: http://ref.x86asm.net/coder32.html#xAB
    if(b == 0xAB){
      c = "stosw";
    }
    
    // 0xB...
    if(b >> 4 == 0xB){
    
      // 0xB0 - 0xB7 mov r8, Imm8
      // Ref: http://ref.x86asm.net/coder32.html#xB0
      if((b & 0b1111) < 0x8){
        o = imm8();
        c = "mov " + r8[n] + "," + toh(o,1);
      }
      
      // 0xB8 - 0xBF mov r16/32, Imm16/32
      // Ref: http://ref.x86asm.net/coder32.html#xB8
      else{
        o = imm16();
        c = "mov " + r16[n] + "," + toh(o,2);
      }
    }
    
    // 0xC4 les ES r16/32 m16:16/32
    // Ref: http://ref.x86asm.net/coder32.html#xC4
    if(b == 0xC4){
      o = imm8();
      c = "les ???";
    }
    
    // 0xCD int imm8 eFlags
    // Ref: http://ref.x86asm.net/coder32.html#xCD
    if(b == 0xCD){
      o = imm8();
      c = "int " + toh(o,1);
    }
    
    // 0xE2 loop eCX rel18
    // Ref: http://ref.x86asm.net/coder32.html#xE2
    if(b == 0xE2){
      o = imm8();
      c = "loop " + toh(a + toSignedOffset8(o),2);
    }
    // 0xEB jmp rel18
    // Ref: http://ref.x86asm.net/coder32.html#xEB
    if(b == 0xEB){
      o = imm8();
      c = "jmp " + toh(a + toSignedOffset8(o),2);
    }

    // 0xF7: many things
    // Ref: http://ref.x86asm.net/coder32.html#xF7
    if(b == 0xf7){
    
      o = imm8();
      
      // 6: div eDX eAx r/m16/32
      if(o == 0xf1){
        c = "div cx";
      }
    }
    
    h += "<tr" + (ok ? " style=background:lightgreen" : "") + "><td>" + to16(a, u.length > 0xFFFF ? 4: 2) + "<td>" + to16(b,l).replace(/../g,"$& ") + "<td>" + c + "\n";
    if(ok) ok--;
  }

  // Write table
  t.innerHTML = h;
}



m8trix.onclick();
m8trix.focus();
</script>